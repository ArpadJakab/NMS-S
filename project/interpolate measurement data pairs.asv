% This script interpolates value pairs where the difference of two neighbouring x-data values
% is random. After the interpolation the x-values will be mixed with equidistant x-values, too,
% and the corresponding y-value is being calculated
% au contains measurement value pairs where x-values (1st row) are not equidistant
% (distinct)

x = au(:,1)
y = au(:,2)
y1 = smooth(y,51)
a = [x,y,y1]

% define interpolation range
b = [a;[[floor(x(1)):ceil(x(end))]', zeros(ceil(x(end))-floor(x(1))+1,1)]]
c = sortrows(b,1)
n = find(c(:,3))
cc = c
for i=1:length(n)-1; d = (c(n(i+1),2) - c(n(i),2)) / ((c(n(i+1),1) - c(n(i),1))); cc(n(i)+1:n(i+1)-1,2) = d * (c(n(i)+1:n(i+1)-1,1) - c(n(i),1)) + c(n(i),2); end
for i=1:length(n)-1; d = (c(n(i+1),3) - c(n(i),3)) / ((c(n(i+1),1) - c(n(i),1))); cc(n(i)+1:n(i+1)-1,3) = d * (c(n(i)+1:n(i+1)-1,1) - c(n(i),1)) + c(n(i),3); end
% remove data that has not been processed (these are values outside of the
% x-range
dd = cc(find(cc(:,3)),:)

% result
au_interp = dd(:,[1,3])
