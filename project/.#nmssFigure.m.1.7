function varargout = nmssFigure(varargin)
% NMSSFIGURE M-file for nmssFigure.fig
%      NMSSFIGURE, by itself, creates a new NMSSFIGURE or raises the existing
%      singleton*.
%
%      H = NMSSFIGURE returns the handle to a new NMSSFIGURE or the handle to
%      the existing singleton*.
%
%      NMSSFIGURE('CALLBACK',hObject,eventData,handles,...) calls the local
%      function named CALLBACK in NMSSFIGURE.M with the given input arguments.
%
%      NMSSFIGURE('Property','Value',...) creates a new NMSSFIGURE or raises the
%      existing singleton*.  Starting from the left, property value pairs are
%      applied to the GUI before nmssFigure_OpeningFunction gets called.  An
%      unrecognized property name or invalid value makes property application
%      stop.  All inputs are passed to nmssFigure_OpeningFcn via varargin.
%
%      *See GUI Options on GUIDE's Tools menu.  Choose "GUI allows only one
%      instance to run (singleton)".
%
% See also: GUIDE, GUIDATA, GUIHANDLES

% Copyright 2002-2003 The MathWorks, Inc.

% Edit the above text to modify the response to help nmssFigure

% Last Modified by GUIDE v2.5 12-Jul-2009 21:09:26

% Begin initialization code - DO NOT EDIT
gui_Singleton = 1;
gui_State = struct('gui_Name',       mfilename, ...
                   'gui_Singleton',  gui_Singleton, ...
                   'gui_OpeningFcn', @nmssFigure_OpeningFcn, ...
                   'gui_OutputFcn',  @nmssFigure_OutputFcn, ...
                   'gui_LayoutFcn',  [] , ...
                   'gui_Callback',   []);
if nargin && ischar(varargin{1})
    gui_State.gui_Callback = str2func(varargin{1});
end

if nargout
    [varargout{1:nargout}] = gui_mainfcn(gui_State, varargin{:});
else
    gui_mainfcn(gui_State, varargin{:});
end
% End initialization code - DO NOT EDIT


% --- Executes just before nmssFigure is made visible.
function nmssFigure_OpeningFcn(hObject, eventdata, handles, varargin)
% This function has no output args, see OutputFcn.
% hObject    handle to figure
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% varargin   command line arguments to nmssFigure (see VARARGIN)


    % Choose default command line output for nmssFigure
    handles.output = hObject;
    
    % store handle of this dialog (or call it figure)
    global app;
    app.nmssFigure = hObject;

    global nmssFigureData;
    global doc;
    
    % register the function which is being called, when the user presses a
    % key while this figure window has focus
    set(hObject, 'KeyPressFcn', @nmssFigure_KeyPressFcn);
    
    % get the original dimensions of the window and its GUI elements
    % (needed for resizing informaions)
    win_size = get(hObject, 'Position');
    canvas_size = get(handles.canvasFigureAxes, 'Position');
    nmssFigureData.canvas.origpos.y = canvas_size(1,2);
    nmssFigureData.canvas.origpos.x = canvas_size(1,1);
    nmssFigureData.canvas.distfromtop = win_size(1,4) - canvas_size(1,2) - canvas_size(1,4);
    nmssFigureData.canvas.distfromright = win_size(1,3) - canvas_size(1,1) - canvas_size(1,3);
    
%     if (doc.sum_up_jobs)
%         nmssFigureData.cur_job_index = -1;
%         job = doc.current_job;
%     else
        % display the last image
        %nmssFigureData.cur_job_index = length(doc.current_job);
        nmssFigureData.cur_job_index = 1;
        job = doc.current_job(nmssFigureData.cur_job_index); % display last job (image)
%     end
    
        
    if(length(doc.img) == 0)
        [status camera_image] = OpenJobAndGetImage(job, doc.workDir);
        
        % job couldn't be opened for whatever reason let's take the next
        % one
        if(strcmp(status, 'ERROR'))
            return;
        end
        doc.img = camera_image;
    end
    
    PaintNewImage(handles.nmssFigure, handles.canvasFigureAxes, doc.img);
    %PaintNewImage(handles);
    
    % display in the window title bar the file name(s) of the displayed
    % file(s)
    set(handles.nmssFigure, 'Name', ['NMSS Figure: ', job.filename]);
    set(handles.editGratingCentralWL, 'String', num2str(job.central_wavelength));
    
    % Update handles structure
    guidata(hObject, handles);

    
    % UIWAIT makes nmssFigure wait for user response (see UIRESUME)
    % uiwait(handles.nmssFigure);

function [status camera_image] = OpenJobAndGetImage(job, curr_dir, varargin)
    camera_image = 0;
    status = 'OK';
    
    % show error messages or not?
    silent = false;
    if (length(varargin) == 1)
        if (strcmp(varargin{1}, 'silent'))
            silent = true;
        else
            error({'Unknown input parameter: ', varargin{1}});
        end
    end

        [status camera_image job] = nmssOpenJobImage(job.filename, curr_dir);

    % job couldn't be opened for whatever reason let's take the next
    % one
    if(strcmp(status, 'ERROR'))
        
        if (silent)
            return;
        else
            errordlg(camera_image);
            return;
        end
    end
    
    camera_image = camera_image';
    

    
    
% --- Outputs from this function are returned to the command line.
function varargout = nmssFigure_OutputFcn(hObject, eventdata, handles) 
% varargout  cell array for returning output args (see VARARGOUT);
% hObject    handle to figure
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

handles.output = handles.canvasFigureAxes;

% Get default command line output from handles structure
varargout{1} = handles.output;

%

function PaintNewImage(hFigure, hAxes, img)
    global doc;
    global nmssFigureData;
    
    doc.figure_axis = nmssSetAxis(doc.figure_axis.unit);
    
    job = doc.current_job(nmssFigureData.cur_job_index);
    
    % conflicting unit settings
    % imaging mode and nanometers
    if (job.central_wavelength == 0 && strcmp(doc.figure_axis.unit.x,'nanometer'))
        % set axis to pixels
        px_units.x = 'pixel';
        px_units.y = 'pixel';
        doc.figure_axis = nmssSetAxis(px_units);
    
    % spectroscopy mode and microns
    elseif (job.central_wavelength ~= 0 && strcmp(doc.figure_axis.unit.x,'micron'))
        % set axis to pixels
        px_units.x = 'pixel';
        px_units.y = 'pixel';
        doc.figure_axis = nmssSetAxis(px_units);
    end

    full_lim.x = ([1, size(img,2)] - size(img,2) / 2.0) * doc.figure_axis.scale.current.x + doc.figure_axis.center.x;
    full_lim.y = ([1, size(img,1)] - size(img,1) / 2.0) * doc.figure_axis.scale.current.y + doc.figure_axis.center.y;
    
    nmssPaintImage('new', img, hFigure, hAxes, full_lim, full_lim);



%
function RefreshImage(hFigure, hAxes, img)
%function RefreshImage(handles)
    global doc;

    full_lim.x = ([1, size(img,2)] - size(img,2) / 2.0) * doc.figure_axis.scale.current.x + doc.figure_axis.center.x;
    full_lim.y = ([1, size(img,1)] - size(img,1) / 2.0) * doc.figure_axis.scale.current.y + doc.figure_axis.center.y;

    figure(hFigure);
    current_limits.x = xlim;
    current_limits.y = ylim;
    
    nmssPaintImage('refresh', img, hFigure, hAxes, full_lim, current_limits);


% --- Executes on button press in btnPan.
function btnPan_Callback(hObject, eventdata, handles)
% hObject    handle to btnPan (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

    % Hint: get(hObject,'Value') returns toggle state of btnPan
    if (get(hObject,'Value'))
        pan on;
    else
        pan off;
    end

% --- Executes on button press in btnZoom.
function btnZoom_Callback(hObject, eventdata, handles)
% hObject    handle to btnZoom (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

    % Hint: get(hObject,'Value') returns toggle state of btnZoom
    if (get(hObject,'Value'))
        zoom on;
    else
        zoom off;
    end

    
function nmssUncheckZoomAndPan(handles)
% handles    structure with handles and user data (see GUIDATA)

% nmssUncheckZoomAndPan unchecks the Zoom and the Pan Button. Call this
% function in case the user clicks any other buttons
    set(handles.btnZoom, 'Value', 0);
    zoom off;
    set(handles.btnPan, 'Value', 0);
    pan off;
    


% --- Executes on mouse press over axes background.
function canvasFigureAxes_ButtonDownFcn(hObject, eventdata, handles)
% hObject    handle to canvasFigureAxes (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
    
    disp('mouse button down');



% --- Executes on button press in btnCalibration.
function btnCalibration_Callback(hObject, eventdata, handles)
% hObject    handle to btnCalibration (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
    nmssUncheckZoomAndPan(handles);
    
    nmssCalibrationDlg();
    nmssCalibrationDlg('Set_Figure', handles.nmssFigure);



% --- Executes on button press in btnDrawLine.
function btnDrawLine_Callback(hObject, eventdata, handles)
% hObject    handle to btnDrawLine (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
    global doc;
    
    nmssUncheckZoomAndPan(handles);

    [xPos1 yPos1] = ginput(1);

    nmssDrawCross(xPos1, yPos1, 3, 3);

    [xPos2 yPos2] = ginput(1);

    nmssDrawCross(xPos2, yPos2, 3, 3);

    % draw line
    line([xPos1; xPos2], [yPos1; yPos2], 'Color','r','LineWidth',2);
   
    
    %line_length_px = sqrt((xPos2-xPos1)^2 + (yPos2-yPos1)^2);
    if (strcmp(doc.figure_axis.unit.x,'nanometer'))
        xline_length = abs(xPos2-xPos1) * doc.figure_axis.scale.current.x;
        yline_length = abs(yPos2-yPos1) * doc.figure_axis.scale.current.y;
        txt = {['Horizontal line length is:'], [num2str(xline_length, '%4.2f'), ' ', doc.figure_axis.unit.x]; ...
               ['Vertical line length is:'], [num2str(yline_length, '%4.2f'), ' ', doc.figure_axis.unit.y]};
    else
        line_length = sqrt((xPos2-xPos1)^2 + (yPos2-yPos1)^2);
        txt = {['Line length is:'], [num2str(line_length, '%4.2f'), ' ', doc.figure_axis.unit.x]};
    end
    
    msgbox_handle = msgbox(txt,'Line Length Measurement','modal');
    
    uiwait(msgbox_handle);
     
    RefreshImage(handles.nmssFigure, handles.canvasFigureAxes, doc.img)
    





% % --- Executes on button press in rbPixels.
% function rbPixels_Callback(hObject, eventdata, handles)
% % hObject    handle to rbPixels (see GCBO)
% % eventdata  reserved - to be defined in a future version of MATLAB
% % handles    structure with handles and user data (see GUIDATA)
% 
% % Hint: get(hObject,'Value') returns toggle state of rbPixels
%     nmssUncheckZoomAndPan(handles);
%     
%     if (get(hObject,'Value'))
%         
%         global app;
%         
%         nmssRefreshImage_method(handles, app.calidata.ratio, 1);
%         % change to pixels representation of the axes
%         
%         % limits defined in microns!
%         xLimits = xlim(handles.canvasFigureAxes);
%         yLimits = ylim(handles.canvasFigureAxes);
%         
%         % axis scaling now in pixels
%         xlim(handles.canvasFigureAxes, xLimits / app.calidata.ratio.x);
%         ylim(handles.canvasFigureAxes, yLimits / app.calidata.ratio.y);
%     else
%         disp('pixels 0');
%         % this prevents the unchecking of the radiobutton if the user
%         % clicks on it while checked
%         set(hObject, 'Value', 1);
%     end
% 
% 
% 
% 
% % --- Executes on button press in rbMicrons.
% function rbMicrons_Callback(hObject, eventdata, handles)
% % hObject    handle to rbMicrons (see GCBO)
% % eventdata  reserved - to be defined in a future version of MATLAB
% % handles    structure with handles and user data (see GUIDATA)
% 
% % Hint: get(hObject,'Value') returns toggle state of rbMicrons
%     nmssUncheckZoomAndPan(handles);
%     
%     if (get(hObject,'Value'))
%         global doc;
%         global app;
%         
%         % limits defined in pixels!
%         xLimits = xlim(handles.canvasFigureAxes);
%         yLimits = ylim(handles.canvasFigureAxes);
%         
%         % axis scaling now in microns
% 
%         xlim(handles.canvasFigureAxes, xLimits * doc.figure_axis.scale.current.x);
%         ylim(handles.canvasFigureAxes, yLimits * doc.figure_axis.scale.current.y);
%         
%         nmssRefreshImage_method(handles, app.calidata.ratio, 0);
%         
%     else
%         disp('microns 0');
%         % this prevents the unchecking of the radiobutton if the user
%         % clicks on it while checked
%         set(hObject, 'Value', 1);
%     end
% 
    


% --- Executes on button press in btnImageProcessing.
function btnImageProcessing_Callback(hObject, eventdata, handles)
% hObject    handle to btnImageProcessing (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

    nmssImageEnhancementDlg();
    nmssImageEnhancementDlg('Set_Figure', handles.nmssFigure);
    
    


% --- Executes on button press in btnAnalysis.
function btnAnalysis_Callback(hObject, eventdata, handles)
% hObject    handle to btnAnalysis (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
    nmssUncheckZoomAndPan(handles);
    
    % disable buttons which may interfere with the dialog
    set(handles.btnChangeAxisUnits, 'Enable', 'off');
    set(handles.btnCalibration, 'Enable', 'off');
    set(handles.btnWavelengthCalibration, 'Enable', 'off');
    set(handles.btnAnalysis, 'Enable', 'off');
    
    % open dialog and wait until it gets closed
    global app;
    app.nmssSpecAnalysisDlg = nmssSpecAnalysisDlg();
    
    
    
    

function handle = nmssFigure_GetHandle()
    handle = handles.nmssFigure;




% --- Executes when nmssFigure is resized.
function nmssFigure_ResizeFcn(hObject, eventdata, handles)
% hObject    handle to nmssFigure (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% 
% fills up the whole available area of the window with the image if the window is getting
% resized.

    win_size = get(hObject, 'Position');
    ctrl_gui_size = get(handles.panelControlGUI, 'Position');
    canvas_size = get(handles.canvasFigureAxes, 'Position');
    
    
    global nmssFigureData;
    canvas_size(1,2) = nmssFigureData.canvas.origpos.y;
    canvas_size(1,4) = win_size(1,4) - nmssFigureData.canvas.origpos.y - nmssFigureData.canvas.distfromtop;
    canvas_size(1,1) = nmssFigureData.canvas.origpos.x;
    canvas_size(1,3) = win_size(1,3) - nmssFigureData.canvas.origpos.x - nmssFigureData.canvas.distfromright;
    
    set(handles.canvasFigureAxes, 'Position', canvas_size);
     




% --- Executes when user attempts to close nmssFigure.
function nmssFigure_CloseRequestFcn(hObject, eventdata, handles)
% hObject    handle to nmssFigure (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

    % clear global variable from the memory. this variable is only used in
    % this m-file
    global app;
    clear nmssFigureData;
    
    
    if (ishandle(app.nmssSpecAnalysisDlg))
        close(app.nmssSpecAnalysisDlg);
    end

% Hint: delete(hObject) closes the figure
delete(hObject);




% --- Executes on button press in btnYCrosssection.
function btnYCrosssection_Callback(hObject, eventdata, handles)
% hObject    handle to btnYCrosssection (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% diaplays the y-crossection of the image at the position selected by the
% user with the mouse
    
    % select the top left corner of ROI
    [start_x, start_y] = ginput(1);
    
    global doc;
    
    crosssec = doc.img(1:size(doc.img,1),floor(start_x));
    crosssec_mean = mean(crosssec);
    crosssec_median = median(crosssec); % this is usually equal with the background
        
    crossec_minus_mean = crosssec - (crosssec_mean + crosssec_median) / 2;
    indices_of_non_zero_values = find(crossec_minus_mean > 0);
    
    crossec_minus_mean_positive = zeros(size(crossec_minus_mean));
    crossec_minus_mean_positive(indices_of_non_zero_values) = crossec_minus_mean(indices_of_non_zero_values);
    
    left_of_peak = crossec_minus_mean_positive(1:floor(start_y),1);
    right_of_peak = crossec_minus_mean_positive(floor(start_y)+1:size(crosssec,1),1);
    
    index_of_right_side_of_peak = find(right_of_peak == 0, 1,'first') + floor(start_y);
    index_of_left_side_of_peak = find(left_of_peak == 0, 1,'last');
    
%     figure('Name','Y-Crossection - processed');
%     plot(crossec_minus_mean_positive);
    figure('Name','Y-Crossection');
    plot(crosssec);
    y_limits = ylim
    disp([index_of_left_side_of_peak index_of_left_side_of_peak]);
    
    line([ceil(start_y) ceil(start_y)], ylim, ...
        'Color', 'k','LineWidth', 1, 'LineStyle', '-.');
    line([index_of_left_side_of_peak index_of_left_side_of_peak], ylim, ...
        'Color', 'r','LineWidth', 1, 'LineStyle', '-.');
    line([index_of_right_side_of_peak index_of_right_side_of_peak], ylim, ...
        'Color', 'r','LineWidth', 1, 'LineStyle', '-.');
    



% --- Executes on button press in btnWavelengthCalibration.
function btnWavelengthCalibration_Callback(hObject, eventdata, handles)
% hObject    handle to btnWavelengthCalibration (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
    global doc;
    if (strcmp(doc.figure_axis.unit.x,'nanometer'))
        errtxt = {['Current x-axis unit is set to nanometers, please change to pixels and start the Wavelength Calibration again!']};
        errordlg(errtxt );
        return;
    end

    % disable buttons wich start functions wich may interfere with the
    % wavelength calibration
    set(handles.btnCalibration , 'Enable','off');
    set(handles.btnChangeAxisUnits , 'Enable','off');
    set(handles.btnWavelengthCalibration , 'Enable','off');
    set(handles.btnAnalysis , 'Enable','off');
    
    nmssWavelengthCalDlg('Set_Figure', handles.nmssFigure);
    % wait until the dialog gets closed
    uiwait(nmssWavelengthCalDlg());

    % enable buttons wich start functions wich may interfere with the
    % wavelength calibration
    set(handles.btnCalibration , 'Enable','on');
    set(handles.btnChangeAxisUnits , 'Enable','on');
    set(handles.btnWavelengthCalibration , 'Enable','on');
    set(handles.btnAnalysis , 'Enable','on');
    


% --- Executes on button press in btnChangeAxisUnits.
function btnChangeAxisUnits_Callback(hObject, eventdata, handles)
% hObject    handle to btnChangeAxisUnits (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
    global doc;
    global app;
    
    if (ishandle(app.nmssSpecAnalysisDlg))
        %close(app.nmssSpecAnalysisDlg);
        delete(app.nmssSpecAnalysisDlg);
    end
    
    nmssUncheckZoomAndPan(handles);
    % retain initial zoom setting
    zoom out;

    orig_axis = doc.figure_axis;
    
    
    uiwait(nmssFigureAxiesUnitDlg());
    
    % user pressed cancel
    if (strcmp(orig_axis.unit.x, doc.figure_axis.unit.x) && strcmp(orig_axis.unit.y, doc.figure_axis.unit.y))
        return;
    end

    % limits defined in pixels!
    xLimits = xlim(handles.canvasFigureAxes);
    yLimits = ylim(handles.canvasFigureAxes);

    new_lim.x = xLimits;
    new_lim.y = yLimits;
    
    % initialize the full size of the image with the pixel values
    full_lim.x = [1, size(doc.img,2)];
    full_lim.y = [1, size(doc.img,1)];
    
    disp(orig_axis.unit.x);
    if (strcmp(orig_axis.unit.x ,'pixel'))
        % get the current axis limits in the defined units
        [new_lim.x new_lim.y] = nmssPixel_2_Unit(xLimits, yLimits, doc.figure_axis.unit);
        % get the full image size in the defined units
        [full_lim.x full_lim.y] = nmssPixel_2_Unit([1, size(doc.img,2)], [1, size(doc.img,1)],doc.figure_axis.unit);
    else
        % figure limits unit was nanometer (if spectrogrphic mode was active) or 
        % micrometer (imaging mode) now we want them in pixels
        % now we have to take the inverse of the scaling factors as we go
        % back to pixels and the scaling facto is defined as <unit> / pixel
        [new_lim.x, new_lim.y] = nmssUnit_2_Pixel(xLimits, yLimits, orig_axis.unit)
    end
    
    nmssPaintImage('new', doc.img, handles.nmssFigure , handles.canvasFigureAxes, full_lim, new_lim);
    
    % set new figure limits as the initial figure limits for zoom
    zoom reset;

   
%



function editGratingCentralWL_Callback(hObject, eventdata, handles)
% hObject    handle to editGratingCentralWL (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of editGratingCentralWL as text
%        str2double(get(hObject,'String')) returns contents of editGratingCentralWL as a double


% --- Executes during object creation, after setting all properties.
function editGratingCentralWL_CreateFcn(hObject, eventdata, handles)
% hObject    handle to editGratingCentralWL (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
    set(hObject,'BackgroundColor',get(0,'defaultUicontrolBackgroundColor'));




% --- Executes on button press in pbPrevImage.
function pbPrevImage_Callback(hObject, eventdata, handles)
% hObject    handle to pbPrevImage (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
    
    global nmssFigureData;
    global doc;

    if (nmssFigureData.cur_job_index > 1)
        
        nmssFigureData.cur_job_index = nmssFigureData.cur_job_index - 1;
        
        job = doc.current_job(nmssFigureData.cur_job_index);

        % set mouse cursor to busy (watch)
        set(handles.nmssFigure,'Pointer','watch');
        [status camera_image] = OpenJobAndGetImage(job, doc.workDir, 'silent');
        % switch back the busy cursor to the normal arrow
        set(handles.nmssFigure,'Pointer','arrow');
        if (~strcmp(status,'OK'))
            return;
        end
        
        % end of the list of selected jobs reached -> switch off the button
        if (nmssFigureData.cur_job_index == 1)
            set(hObject,'Enable','off');
        end
        
        % activate the other button
        set(handles.pbNextImage,'Enable','on');
        
        
        RefreshImage(handles.nmssFigure, handles.canvasFigureAxes, camera_image);
        set(handles.nmssFigure, 'Name', ['NMSS Figure: ', job.filename]);
    else
        set(hObject,'Enable','off');        
    end



% --- Executes on button press in pbNextImage.
function pbNextImage_Callback(hObject, eventdata, handles)
% hObject    handle to pbNextImage (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
    if (GetNextImage() == 0)
        set(hObject,'Enable','off');
    end
    % activate the other button
    set(handles.pbPrevImage,'Enable','on');
    
%----------------    
function job_index = GetNextImage()

    global nmssFigureData;
    global doc;
    global app;
    
    handles = guidata(app.nmssFigure);
    
    job_index = 0;
    if (nmssFigureData.cur_job_index < length(doc.current_job))
        
        nmssFigureData.cur_job_index = nmssFigureData.cur_job_index + 1;
        
        job = doc.current_job(nmssFigureData.cur_job_index);

        % set mouse cursor to busy (watch)
        set(handles.nmssFigure,'Pointer','watch');
        [status camera_image] = OpenJobAndGetImage(job, doc.workDir, 'silent');
        % switch back the busy cursor to the normal arrow
        set(handles.nmssFigure,'Pointer','arrow');
        
        if (~strcmp(status,'OK'))
            return;
        end
        
        % end of the list of selected jobs reached -> switch off the button
        if (nmssFigureData.cur_job_index == length(doc.current_job))
            job_index = 0;
        else
            job_index = nmssFigureData.cur_job_index;
        end
        
        RefreshImage(handles.nmssFigure, handles.canvasFigureAxes, camera_image);
        set(handles.nmssFigure, 'Name', ['NMSS Figure: ', job.filename]);
    end




% --------------------------------------------------------------------
function mnFigure_Callback(hObject, eventdata, handles)
% hObject    handle to mnFigure (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --- Executes on key press over nmssFigure with no controls selected.
function nmssFigure_KeyPressFcn(src, eventdata)
% src    handle to nmssFigure (see GCBO)
% eventdata  - a structure which contains necessary infromations about the
% key event. eventdata.Modifier = 'alt', 'ctrl', 'shift' etc..
% eventdata.Key = the name of the key, that is pressed


%     last_char = get(hObject, 'CurrentCharacter');
%     selection_type = get(hObject, 'SelectionType');
%     disp(['Key pressed: ', last_char, ' Selection Type:', selection_type]);

    global app;
    
    % get structure of the child gui elements
    handles = guidata(app.nmssFigure);
    
    if (length(eventdata.Modifier) == 0)
            if (strcmp(eventdata.Key, 'rightarrow'))
                % call next image
                pbNextImage_Callback(handles.pbNextImage, eventdata, handles)
            elseif (strcmp(eventdata.Key, 'leftarrow'))
                % call prev image
                pbPrevImage_Callback(handles.pbPrevImage, eventdata, handles)
            end
    end
    
    



% --------------------------------------------------------------------
function menuManualPartilceTracking_Callback(hObject, eventdata, handles)
% hObject    handle to menuManualPartilceTracking (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

    global app;
    global nmssFigureData;
    global doc;
    %global nmsstest;
    strHelp = {'Use this feature to track particles with the mouse on subsequent images.';; ...
               'Use the left mouse button to mark the a particle on this images.'; ...
               'After pressing, the next image will be loaded, and proceed until'; ...
               'You reach the last image.';; ...
               'Press right mouse button to skip the current image (in case the image is corrupted).';...
        };
    uiwait(helpdlg(strHelp,'Particle tracking tool'));
    
    disp('start');
    
    
    % activate figure containing the image
    figure(app.nmssFigure);
    
    k = 1;
    xPos = [];
    yPos = [];
    posJob = [];
    job_index = nmssFigureData.cur_job_index;
    
% TEST
    %     if (isfield(nmsstest, 'xPos') & isfield(nmsstest, 'yPos') & isfield(nmsstest, 'posJob'))
%         xPos = nmsstest.xPos;
%         yPos = nmsstest.yPos;
%         posJob = nmsstest.posJob;
%     else
% END OF TEST
        while (job_index ~= 0)
            [x, y, button] = ginput(1);
            if (button == 2)
                continue;
            end
            nmssDrawCross(x, y, 3, 3);

            % remember particle position and job index
            xPos(k) = x;
            yPos(k) = y;
            posJob(k) = job_index;

            % increase array index
            k=k+1;

            % get next job
            job_index = GetNextImage();
            if (job_index == 0)
                break;
            end
        end
%         % TEST -----------------------------
%         nmsstest.xPos = xPos;
%         nmsstest.yPos = yPos;
%         nmsstest.posJob = posJob;
%         % TEST -----------------------------
%     end % end else
    
    figure; plot(xPos, yPos);
    
    % calc max x,y and min x,y of the particle location
    x_min = min(xPos);
    x_max = max(xPos);
    
    y_min = min(yPos);
    y_max = max(yPos);
    
    % calc center positions
    x_center = (x_min + x_max) / 2.0;
    y_center = (y_min + y_max) / 2.0;
    
    
    button = questdlg({'Do you want to export jobs with applied drift correction?'},'Job Export Dialog','Yes','No','Yes');
    if (strcmp(button,'No'))
        return; % user canceled drift correction
    end
    
    % get directory to export the jobs  
    export_dir = uigetdir(doc.workDir, 'Select export directory');
    
    % directory selected
    if (export_dir == 0)
        return; % user canceled drift correction
    end
    
    % --------------------------------------------------
    % apply drift correction to each job and export them
    % --------------------------------------------------
    
    
    % get job structure
    num_of_jobs = length(doc.current_job);
    num_of_pos = length(posJob);
    
    % the indices of the jobs with drift correction infromation
    for i=1:num_of_pos-1
        
        dx = floor(x_center - xPos(i) + 0.5);
        dy = floor(y_center - yPos(i) + 0.5);
        
        % jobs that receive the same drift correction
        for k=posJob(i):posJob(i+1)-1
            job = doc.current_job(k);
            
            [status camera_image] = OpenJobAndGetImage(job, doc.workDir, 'silent');
            new_img = camera_image;
            
            % apply drift correction
            if (dx >= 0 & dy >= 0)
                new_img(1+dy:end, 1+dx:end) = camera_image(1:end-dy, 1:end-dx);
            elseif (dx >= 0 & dy <= 0)
                new_img(1:end+dy, 1+dx:end) = camera_image(1-dy:end, 1:end-dx);
            elseif (dx <= 0 & dy >= 0)
                new_img(1+dy:end, 1:end+dx) = camera_image(1:end-dy, 1-dx:end);
            else
                try
                    new_img(1:end+dy, 1:end+dx) = camera_image(1-dy:end, 1-dx:end);
                catch
                    keyboard;
                end
            end
            
            % now we have to save the jobs
            filepath = fullfile(export_dir, job.filename);
            nmssSaveJob(filepath, job, new_img');
        end
    end
    
    % save list_of_jobs.mat
    filepath = fullfile(export_dir, 'list_of_jobs.mat');
    try
        list_of_jobs = doc.list_of_jobs;
        measurement_info = doc.measurement_info;
        save(filepath, 'list_of_jobs', 'measurement_info', '-mat');
    catch
        error_msg = ['Error saving file: ' lasterr()];
        disp(error_msg);
        errordlg(error_msg);
    end
    
    
    
    
    
    
    
    
    
    


% --------------------------------------------------------------------
function menu_SaveAs_Callback(hObject, eventdata, handles)
% hObject    handle to menu_SaveAs (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
    global doc;
    job = doc.current_job;

    old_dir = pwd;
    
    cd(doc.workDir);
    
    c = clock();
    
    def_file_name = ['Single_Exp_', num2str(c(1)), '-', num2str(c(2)), '-', num2str(c(3)), ...
                     '_h', num2str(c(4)), 'm', num2str(c(5)), 's', num2str(floor(c(6))), '.mat'];
    
    
    [filename, dirname, filterIndex] = uiputfile({'*.mat', 'Save Graph as Mat-File...'}, 'Save Job As...', def_file_name);

    cd(old_dir);
    
    % user hit cancel button
    if (filename == 0)
        return;
    end
    
    % check for extension if user hasn't given any, append .mat at the end
    [pathstr,name,ext,versn] = fileparts(filename);
    if (isempty(ext))
        filename = [filename,'.mat'];
    end
    
    % the file name of the job
    job.filename = filename;
        
    filepath = fullfile(dirname, filename);
    camera_image = doc.img;
    nmssSaveJob( filepath, job, camera_image');



% --------------------------------------------------------------------
function file_Menu_Callback(hObject, eventdata, handles)
% hObject    handle to file_Menu (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)




% --------------------------------------------------------------------
function mnCaliLateral_Callback(hObject, eventdata, handles)
% hObject    handle to mnCaliLateral (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
    nmssUncheckZoomAndPan(handles);
    
    nmssCalibrationDlg();
    nmssCalibrationDlg('Set_Figure', handles.nmssFigure);


% --------------------------------------------------------------------
function mnCaliSpectral_Callback(hObject, eventdata, handles)
% hObject    handle to mnCaliSpectral (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
    global doc;
    if (strcmp(doc.figure_axis.unit.x,'nanometer'))
        errtxt = {['Current x-axis unit is set to nanometers, please change to pixels and start the Wavelength Calibration again!']};
        errordlg(errtxt );
        return;
    end

    % disable buttons wich start functions wich may interfere with the
    % wavelength calibration
    set(handles.mnCaliSpectral , 'Enable','off');
    set(handles.btnChangeAxisUnits , 'Enable','off');
    set(handles.mnCaliLateral , 'Enable','off');
    set(handles.mnAnalysis , 'Enable','off');
    
    nmssWavelengthCalDlg('Set_Figure', handles.nmssFigure);
    % wait until the dialog gets closed
    uiwait(nmssWavelengthCalDlg());

    % enable buttons wich start functions wich may interfere with the
    % wavelength calibration
    set(handles.mnCaliSpectral , 'Enable','on');
    set(handles.btnChangeAxisUnits , 'Enable','on');
    set(handles.mnCaliLateral , 'Enable','on');
    set(handles.mnAnalysis , 'Enable','on');


% --------------------------------------------------------------------
function mnCalibration_Callback(hObject, eventdata, handles)
% hObject    handle to mnCalibration (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --------------------------------------------------------------------
function mnAnalysis_Callback(hObject, eventdata, handles)
% hObject    handle to mnAnalysis (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

    % open dialog only if itis not opened yet
    global app;
    if (~ishandle(app.nmssSpecAnalysisDlg))
        nmssUncheckZoomAndPan(handles);

        app.nmssSpecAnalysisDlg = nmssSpecAnalysisDlg();
    end
    
    

% --------------------------------------------------------------------
function mnBrightContrast_Callback(hObject, eventdata, handles)
% hObject    handle to mnBrightContrast (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

    nmssImageEnhancementDlg();

% --------------------------------------------------------------------
function mnTools_Callback(hObject, eventdata, handles)
% hObject    handle to mnTools (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --------------------------------------------------------------------
function mnImage_Callback(hObject, eventdata, handles)
% hObject    handle to mnImage (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)




% --- Executes on button press in btnCrossSection.
function btnCrossSection_Callback(hObject, eventdata, handles)
% hObject    handle to btnCrossSection (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
        
    global doc;
    global nmssFigureData;
    image_full_limits = nmssGetFullImageLimits(doc.figure_axis.unit);

    hAxis = gca;
    

    % select the top left corner of ROI
    [start_x, start_y] = ginput(1);

    set(hAxis, 'Units', 'pixels');
    axis_pos = get(gca, 'Position');
    
    % get the current view limits
    xlimits = xlim(hAxis);
    ylimits = ylim(hAxis);
    
    % get the axis x-size
    axis_size_x = axis_pos(3);
    % get the axis y-size
    axis_size_y = axis_pos(4);

    % set up ROIs that will contain the cross sections
    cs_x_roi = nmssResetROI();
    cs_y_roi = nmssResetROI();

    cs_x_roi.exists = 1;
    cs_x_roi.valid = 1;
    cs_x_roi.x = image_full_limits.x(1);
    cs_x_roi.y = ceil(start_y);
    
    cs_y_roi.exists = 1;
    cs_y_roi.valid = 1;
    cs_y_roi.x = ceil(start_x);
    cs_y_roi.y = image_full_limits.y(1);
    
    cs_x_roi.wx = image_full_limits.x(2);
    cs_x_roi.wy = 1;

    cs_y_roi.wx = 1;
    cs_y_roi.wy = image_full_limits.y(2);

    if (~strcmp(doc.figure_axis.unit.x,'pixel'))
        cs_x_roi_px = ConvertROIUnit2Pixel(cs_x_roi, doc.figure_axis.unit);
        cs_y_roi_px = ConvertROIUnit2Pixel(cs_y_roi, doc.figure_axis.unit);
    else
        cs_x_roi_px = cs_x_roi;
        cs_y_roi_px = cs_y_roi;
    end
    
    % get image data for the given cross section
    cs_x = doc.img(cs_x_roi_px.y : cs_x_roi_px.y + cs_x_roi_px.wy - 1, ...
                   cs_x_roi_px.x : cs_x_roi_px.x + cs_x_roi_px.wx - 1);
               
    cs_y = doc.img(cs_y_roi_px.y : cs_y_roi_px.y + cs_y_roi_px.wy - 1, ...
                   cs_y_roi_px.x : cs_y_roi_px.x + cs_y_roi_px.wx - 1);

            % background signal
            roi = doc.roi;
            img = doc.img;
            median_bg = 0;
            if (roi.bg1.exists == 1 || roi.bg2.exists == 1)
                if (roi.bg1.valid == 1)
                    bg = img(roi.bg1.y : roi.bg1.y+roi.bg1.wy - 1,...
                                roi.bg1.x : roi.bg1.x+roi.bg1.wx - 1);
                    median_bg = cast(median(median(bg)), 'double');
                    
                elseif (roi.bg2.valid == 1)
                    %bg = img(roi.bg2.y : roi.bg2.y+roi.bg2.wy - 1,...
                    %            roi.bg2.x : roi.bg2.x+roi.bg2.wx - 1);
                    
                    % we split the background roi (which contains also the
                    % particle roi) into four regions, illustrated like
                    % below (P = particle roi)
                    % 132
                    % 1P2
                    % 142
                                
                    real_bg_1 = img(roi.bg2.y : roi.bg2.y+roi.bg2.wy - 1, ...
                                    roi.bg2.x : roi.particle.x - 1);
                    real_bg_2 = img(roi.bg2.y : roi.bg2.y+roi.bg2.wy - 1, ...
                                    roi.particle.x+roi.particle.wx : roi.bg2.x+roi.bg2.wx - 1);
                    real_bg_3 = img(roi.bg2.y : roi.particle.y - 1, ...
                                    roi.particle.x : roi.particle.x+roi.particle.wx - 1);
                    real_bg_4 = img(roi.particle.y + roi.particle.wy : roi.bg2.y+roi.bg2.wy - 1, ...
                                    roi.particle.x : roi.particle.x+roi.particle.wx - 1);
                    
                    real_bg = [real_bg_1(:); real_bg_2(:); real_bg_3(:); real_bg_4(:)];
                    median_bg = cast(median(real_bg),'double');
                    
                end
            end
                   
               
    % display cross sections
    % x cross section
    hFig_x_cs = figure;
    plot(image_full_limits.x(1):image_full_limits.x(2),cs_x, '.--');
    title('X cross section');
    plot_y_limits = ylim();
    % get particle and background ROI data to display them on the cross section plot 
    if (doc.roi.particle.valid == 1)
        line([doc.roi.particle.x, doc.roi.particle.x], [plot_y_limits(1), plot_y_limits(2)], ...
             'LineStyle', '-', 'Color', 'g');
        line([doc.roi.particle.x+doc.roi.particle.wx-1, doc.roi.particle.x+doc.roi.particle.wx-1], ...
             [plot_y_limits(1), plot_y_limits(2)], ...
             'LineStyle', '-', 'Color', 'g');
    end
    if (doc.roi.bg1.valid == 1)
        line([doc.roi.bg1.x, doc.roi.bg1.x], [plot_y_limits(1), plot_y_limits(2)], ...
             'LineStyle', '--', 'Color', 'g');
        line([doc.roi.bg1.x+doc.roi.bg1.wx-1, doc.roi.bg1.x+doc.roi.bg1.wx-1], ...
             [plot_y_limits(1), plot_y_limits(2)], ...
             'LineStyle', '--', 'Color', 'g');
    elseif (doc.roi.bg2.valid == 1)
        line([doc.roi.bg2.x, doc.roi.bg2.x], [plot_y_limits(1), plot_y_limits(2)], ...
             'LineStyle', '--', 'Color', 'g');
        line([doc.roi.bg2.x+doc.roi.bg2.wx-1, doc.roi.bg2.x+doc.roi.bg2.wx-1], ...
             [plot_y_limits(1), plot_y_limits(2)], ...
             'LineStyle', '--', 'Color', 'g');
    end
    
    line([image_full_limits.x(1),image_full_limits.x(2)], [median_bg, median_bg], 'LineStyle', '-', 'Color', 'k');
    % set corresponding zoom
    xlim(xlimits);
    
    
    
    
    % y cross section
    hFig_y_cs = figure;
    plot(cs_y, image_full_limits.y(1):image_full_limits.y(2), '.--');
    title('Y cross section');
    plot_x_limits = xlim();
    % get particle and background ROI data to display them on the cross section plot 
    if (doc.roi.particle.valid == 1)
        line([plot_x_limits(1), plot_x_limits(2)], [doc.roi.particle.y, doc.roi.particle.y], ...
             'LineStyle', '-', 'Color', 'g');
        line([plot_x_limits(1), plot_x_limits(2)], ...
             [doc.roi.particle.y+doc.roi.particle.wy-1, doc.roi.particle.y+doc.roi.particle.wy-1], ...
             'LineStyle', '-', 'Color', 'g');
    end
    if (doc.roi.bg1.valid == 1)
        line([plot_x_limits(1), plot_x_limits(2)], [doc.roi.bg1.y, doc.roi.bg1.y], ...
             'LineStyle', '--', 'Color', 'g');
        line([plot_x_limits(1), plot_x_limits(2)], ...
             [doc.roi.bg1.y+doc.roi.bg1.wy-1, doc.roi.bg1.y+doc.roi.bg1.wy-1], ...
             'LineStyle', '--', 'Color', 'g');
    elseif (doc.roi.bg2.valid == 1)
        line([plot_x_limits(1), plot_x_limits(2)], [doc.roi.bg2.y, doc.roi.bg2.y], ...
             'LineStyle', '--', 'Color', 'g');
        line([plot_x_limits(1), plot_x_limits(2)], ...
             [doc.roi.bg2.y+doc.roi.bg2.wy-1, doc.roi.bg2.y+doc.roi.bg2.wy-1], ...
             'LineStyle', '--', 'Color', 'g');
    end
    line([median_bg, median_bg], [image_full_limits.y(1),image_full_limits.y(2)], 'LineStyle', '-', 'Color', 'k');
    
    ylim(ylimits);
    handle_axes = findobj(hFig_y_cs,'type','axes');
    set(handle_axes,'YDir','reverse');
    
               
        
        
        
        
        
        
%         
%         % snap rectangle's coordinates to the outer boundary of the pixels
%         % contained within or which are on the rubber box line
%         corner_x = floor(start_x + 0.5);
%         corner_y = floor(start_y + 0.5);
%         
%         full_lim = nmssGetFullImageLimits(doc.figure_axis.unit);
%         if (corner_x < full_lim.x(1))
%             corner_x = full_lim.x(1);
%         end
%         
%         if (corner_y < full_lim.y(1))
%             corner_y = full_lim.y(1);
%         end

